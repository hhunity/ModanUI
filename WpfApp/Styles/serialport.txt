####view model
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

public partial class MainViewModel : ObservableObject
{
    private readonly SerialPortWorker _serialWorker;

    [ObservableProperty]
    private string serialData;

    [ObservableProperty]
    private string commandText;

    public MainViewModel()
    {
        _serialWorker = new SerialPortWorker("COM3", OnReceived);
        _serialWorker.Start();
    }

    private void OnReceived(string data)
    {
        // UIスレッドで更新（DispatcherはSerialPortWorker内で呼んでる）
        SerialData = data;
    }

    [RelayCommand]
    public async Task SendCommandAsync()
    {
        await _serialWorker.WriteAsync(CommandText);
    }

    public void Dispose()
    {
        _serialWorker.Close();
    }
}

##model
using System;
using System.IO.Ports;
using System.Threading.Tasks;
using System.Windows;
using System.Diagnostics;

public class SerialPortWorker
{
    private readonly SerialPort _port;
    private readonly Action<string> _onDataReceived;

    public SerialPortWorker(string portName, Action<string> onDataReceived)
    {
        _onDataReceived = onDataReceived;
        _port = new SerialPort(portName, 9600)
        {
            NewLine = "\n",
            ReadTimeout = 1000,
            WriteTimeout = 1000
        };

        _port.DataReceived += Port_DataReceived;
    }

    public void Start()
    {
        if (!_port.IsOpen)
            _port.Open();
    }

    public void Close()
    {
        if (_port.IsOpen)
        {
            _port.DataReceived -= Port_DataReceived;
            _port.Close();
        }
    }

    public Task WriteAsync(string command)
    {
        return Task.Run(() =>
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(command))
                    _port.WriteLine(command);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Write error: {ex.Message}");
            }
        });
    }

    private void Port_DataReceived(object sender, SerialDataReceivedEventArgs e)
    {
        try
        {
            string data = _port.ReadLine(); // バッファに入ってる分を読む

            Application.Current.Dispatcher.Invoke(() =>
            {
                _onDataReceived?.Invoke(data);
            });
        }
        catch (TimeoutException)
        {
            // 読み取り中のタイムアウトは無視
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Receive error: {ex.Message}");
        }
    }
}

##xaml
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp"
        mc:Ignorable="d"
        Title="Serial (Event-based)" Height="200" Width="400">
    <StackPanel Margin="20">
        <TextBox Text="{Binding CommandText, UpdateSourceTrigger=PropertyChanged}" />
        <Button Content="Send" Command="{Binding SendCommandCommand}" Margin="0,10,0,0"/>
        <TextBlock Text="{Binding SerialData}" Margin="0,10,0,0" FontSize="16"/>
    </StackPanel>
</Window>


###view
public partial class MainWindow : Window
{
    private readonly MainViewModel _viewModel = new();

    public MainWindow()
    {
        InitializeComponent();
        DataContext = _viewModel;
    }

    protected override void OnClosed(EventArgs e)
    {
        _viewModel.Dispose();
        base.OnClosed(e);
    }
}





